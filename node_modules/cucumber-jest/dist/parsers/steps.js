"use strict";

var _Object$keys = require("@babel/runtime-corejs3/core-js-stable/object/keys");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols");

var _filterInstanceProperty = require("@babel/runtime-corejs3/core-js-stable/instance/filter");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor");

var _forEachInstanceProperty = require("@babel/runtime-corejs3/core-js-stable/instance/for-each");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors");

var _Object$defineProperties = require("@babel/runtime-corejs3/core-js-stable/object/define-properties");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.generateSnippet = generateSnippet;
exports.parseSteps = parseSteps;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/toConsumableArray"));

var _trim = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/trim"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _data_table = _interopRequireDefault(require("@cucumber/cucumber/lib/models/data_table"));

var _chalk = _interopRequireDefault(require("chalk"));

var _outdent = require("outdent");

var _space = require("../configs/space");

var _isJson = require("../utils/isJson");

var _table = require("./table");

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context6; _forEachInstanceProperty(_context6 = ownKeys(Object(source), true)).call(_context6, function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { var _context7; _forEachInstanceProperty(_context7 = ownKeys(Object(source))).call(_context7, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

function generateSnippet(step) {
  var _context;

  return (0, _outdent.outdent)`
        ${_chalk.default.red('[error]')} could not find a step with pattern that matches the text:\n		
        ${_chalk.default.yellow(step.text)}\n
        Implement with the following snippet:\n
        ${(0, _trim.default)(_context = step.keyword).call(_context)}("${step.text}", function () {
            // Write code here
        });
        \n
    `;
}

function parseSteps(steps, definitions) {
  const _fn = (acc, step) => {
    var _context2, _definition$expressio, _definition$expressio2, _definition$expressio3, _context3, _context4, _context5;

    let _result2;

    for (let _key2 = 0, _length2 = definitions.length, _value2; _key2 < _length2; ++_key2) {
      _value2 = definitions[_key2];

      if (_value2.matchesStepName(step.text)) {
        _result2 = _value2;
        break;
      }
    }

    const definition = _result2;
    let _result3 = [];

    for (let _key3 = 0, _length3 = definitions.length, _value3; _key3 < _length3; ++_key3) {
      _value3 = definitions[_key3];
      if (_value3.matchesStepName(step.text)) _result3.push(_value3);
    }

    const multiSteps = _result3;

    if (!definition) {
      throw new Error(generateSnippet(step));
    }

    if (multiSteps.length > 1) {
      process.stdout.write(`${_chalk.default.yellow('Warning:')}\nmultiple steps found\nstep:${_chalk.default.yellow(step.text)}\npatterns:\n${(0, _map.default)(multiSteps).call(multiSteps, step => `- ${step.pattern.toString()}`).join('\n')}\n`);
    }

    const stepArgs = (0, _concat.default)(_context2 = []).call(_context2, (0, _toConsumableArray2.default)((_definition$expressio = (_definition$expressio2 = definition.expression) === null || _definition$expressio2 === void 0 ? void 0 : (_definition$expressio3 = _definition$expressio2.match(step.text)) === null || _definition$expressio3 === void 0 ? void 0 : (0, _map.default)(_definition$expressio3).call(_definition$expressio3, arg => arg.getValue())) !== null && _definition$expressio !== void 0 ? _definition$expressio : []), (0, _toConsumableArray2.default)(step.dataTable ? [new _data_table.default(step.dataTable)] : []), (0, _toConsumableArray2.default)(step.docString ? [(0, _isJson.isJson)(step.docString.content) ? JSON.parse(step.docString.content) : step.docString.content] : []));
    const type = (0, _trim.default)(_context3 = step.keyword || '').call(_context3).toLowerCase();

    if (acc.last !== type && type !== 'and' && type !== 'but') {
      acc.last = type;
    }

    const tableDescription = step.dataTable ? '\n' + (0, _table.createDataTable)(stepArgs[stepArgs.length - 1].rawTable) : '';
    const docStringDescription = step.docString ? '\n' + (0, _map.default)(_context4 = step.docString.content.split('\n')).call(_context4, row => _space.space + `${row}`).join('\n') : '';
    return _objectSpread(_objectSpread({}, acc), {}, {
      [acc.last]: (0, _concat.default)(_context5 = []).call(_context5, (0, _toConsumableArray2.default)(acc[acc.last] || []), [_objectSpread(_objectSpread({
        description: `${step.keyword}${step.text}${tableDescription}${docStringDescription}`
      }, step), {}, {
        code: definition.code,
        stepArgs
      })])
    });
  };

  let _result = {
    last: 'given',
    given: [],
    when: [],
    then: []
  };

  for (let _key = 0, _length = steps.length, _value; _key < _length; ++_key) {
    _value = steps[_key];
    _result = _fn(_result, _value, _key, steps);
  }

  return _result;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXJzZXJzL3N0ZXBzLnRzIl0sIm5hbWVzIjpbImdlbmVyYXRlU25pcHBldCIsInN0ZXAiLCJjaGFsayIsInJlZCIsInllbGxvdyIsInRleHQiLCJrZXl3b3JkIiwicGFyc2VTdGVwcyIsInN0ZXBzIiwiZGVmaW5pdGlvbnMiLCJhY2MiLCJkZWYiLCJtYXRjaGVzU3RlcE5hbWUiLCJkZWZpbml0aW9uIiwibXVsdGlTdGVwcyIsIkVycm9yIiwibGVuZ3RoIiwicHJvY2VzcyIsInN0ZG91dCIsIndyaXRlIiwicGF0dGVybiIsInRvU3RyaW5nIiwiam9pbiIsInN0ZXBBcmdzIiwiZXhwcmVzc2lvbiIsIm1hdGNoIiwiYXJnIiwiZ2V0VmFsdWUiLCJkYXRhVGFibGUiLCJEYXRhVGFibGUiLCJkb2NTdHJpbmciLCJjb250ZW50IiwiSlNPTiIsInBhcnNlIiwidHlwZSIsInRvTG93ZXJDYXNlIiwibGFzdCIsInRhYmxlRGVzY3JpcHRpb24iLCJyYXdUYWJsZSIsImRvY1N0cmluZ0Rlc2NyaXB0aW9uIiwic3BsaXQiLCJyb3ciLCJzcGFjZSIsImRlc2NyaXB0aW9uIiwiY29kZSIsImdpdmVuIiwid2hlbiIsInRoZW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFFQTs7QUFFQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRU8sU0FBU0EsZUFBVCxDQUF5QkMsSUFBekIsRUFBdUM7QUFBQTs7QUFDMUMsU0FBTyxxQkFBUTtBQUNuQixVQUFVQyxlQUFNQyxHQUFOLENBQ0UsU0FERixDQUVBO0FBQ1YsVUFBVUQsZUFBTUUsTUFBTixDQUFhSCxJQUFJLENBQUNJLElBQWxCLENBQXdCO0FBQ2xDO0FBQ0EsVUFBVSw4QkFBQUosSUFBSSxDQUFDSyxPQUFMLGdCQUFvQixLQUFJTCxJQUFJLENBQUNJLElBQUs7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsS0FWSTtBQVdIOztBQUVNLFNBQVNFLFVBQVQs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QUFILElBQWlCLEVBRHpCO0FBR1FPLFFBQUFBLFdBQVcsRUFBRyxHQUFFMUMsSUFBSSxDQUFDSyxPQUFRLEdBQUVMLElBQUksQ0FBQ0ksSUFBSyxHQUFFZ0MsZ0JBQWlCLEdBQUVFLG9CQUFxQjtBQUgzRixTQUlXdEMsSUFKWDtBQUtRMkMsUUFBQUEsSUFBSSxFQUFFL0IsVUFBVSxDQUFDK0IsSUFMekI7QUFNUXJCLFFBQUFBO0FBTlI7QUFGSjtBQVlILEdBeEVzQzs7QUFBQSxnQkF5RXZDO0FBQ0lhLElBQUFBLElBQUksRUFBRSxPQURWO0FBRUlTLElBQUFBLEtBQUssRUFBRSxFQUZYO0FBR0lDLElBQUFBLElBQUksRUFBRSxFQUhWO0FBSUlDLElBQUFBLElBQUksRUFBRTtBQUpWLEdBekV1Qzs7QUFBQSwrQkFFdkN2QyxLQUZ1QztBQUFBLGFBRXZDQSxLQUZ1QztBQUFBLHlDQUV2Q0EsS0FGdUM7QUFBQTs7QUFDM0M7QUErRUgiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGF0YVRhYmxlIGZyb20gJ0BjdWN1bWJlci9jdWN1bWJlci9saWIvbW9kZWxzL2RhdGFfdGFibGUnO1xuaW1wb3J0IGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCB7ZmlsdGVyLCBmaW5kLCByZWR1Y2V9IGZyb20gJ2lubGluZS1sb29wcy5tYWNybyc7XG5pbXBvcnQge291dGRlbnR9IGZyb20gJ291dGRlbnQnO1xuXG5pbXBvcnQge3NwYWNlfSBmcm9tICcuLi9jb25maWdzL3NwYWNlJztcbmltcG9ydCB7aXNKc29ufSBmcm9tICcuLi91dGlscy9pc0pzb24nO1xuaW1wb3J0IHtjcmVhdGVEYXRhVGFibGV9IGZyb20gJy4vdGFibGUnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTbmlwcGV0KHN0ZXApOiBzdHJpbmcge1xuICAgIHJldHVybiBvdXRkZW50YFxuICAgICAgICAke2NoYWxrLnJlZChcbiAgICAgICAgICAgICdbZXJyb3JdJ1xuICAgICAgICApfSBjb3VsZCBub3QgZmluZCBhIHN0ZXAgd2l0aCBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyB0aGUgdGV4dDpcXG5cdFx0XG4gICAgICAgICR7Y2hhbGsueWVsbG93KHN0ZXAudGV4dCl9XFxuXG4gICAgICAgIEltcGxlbWVudCB3aXRoIHRoZSBmb2xsb3dpbmcgc25pcHBldDpcXG5cbiAgICAgICAgJHtzdGVwLmtleXdvcmQudHJpbSgpfShcIiR7c3RlcC50ZXh0fVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBXcml0ZSBjb2RlIGhlcmVcbiAgICAgICAgfSk7XG4gICAgICAgIFxcblxuICAgIGA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVN0ZXBzKHN0ZXBzLCBkZWZpbml0aW9ucykge1xuICAgIHJldHVybiByZWR1Y2UoXG4gICAgICAgIHN0ZXBzLFxuICAgICAgICAoYWNjLCBzdGVwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gZmluZChkZWZpbml0aW9ucywgKGRlZikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWYubWF0Y2hlc1N0ZXBOYW1lKHN0ZXAudGV4dCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgbXVsdGlTdGVwcyA9IGZpbHRlcihkZWZpbml0aW9ucywgKGRlZikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWYubWF0Y2hlc1N0ZXBOYW1lKHN0ZXAudGV4dCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdlbmVyYXRlU25pcHBldChzdGVwKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtdWx0aVN0ZXBzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShcbiAgICAgICAgICAgICAgICAgICAgYCR7Y2hhbGsueWVsbG93KFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1dhcm5pbmc6J1xuICAgICAgICAgICAgICAgICAgICApfVxcbm11bHRpcGxlIHN0ZXBzIGZvdW5kXFxuc3RlcDoke2NoYWxrLnllbGxvdyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAudGV4dFxuICAgICAgICAgICAgICAgICAgICApfVxcbnBhdHRlcm5zOlxcbiR7bXVsdGlTdGVwc1xuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoc3RlcCkgPT4gYC0gJHtzdGVwLnBhdHRlcm4udG9TdHJpbmcoKX1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpfVxcbmBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzdGVwQXJncyA9IFtcbiAgICAgICAgICAgICAgICAuLi4oZGVmaW5pdGlvbi5leHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgID8ubWF0Y2goc3RlcC50ZXh0KVxuICAgICAgICAgICAgICAgICAgICA/Lm1hcCgoYXJnKSA9PiBhcmcuZ2V0VmFsdWUoKSkgPz8gW10pLFxuICAgICAgICAgICAgICAgIC4uLihzdGVwLmRhdGFUYWJsZSA/IFtuZXcgRGF0YVRhYmxlKHN0ZXAuZGF0YVRhYmxlKV0gOiBbXSksXG4gICAgICAgICAgICAgICAgLi4uKHN0ZXAuZG9jU3RyaW5nXG4gICAgICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc0pzb24oc3RlcC5kb2NTdHJpbmcuY29udGVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gSlNPTi5wYXJzZShzdGVwLmRvY1N0cmluZy5jb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzdGVwLmRvY1N0cmluZy5jb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICA6IFtdKVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IChzdGVwLmtleXdvcmQgfHwgJycpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAoYWNjLmxhc3QgIT09IHR5cGUgJiYgdHlwZSAhPT0gJ2FuZCcgJiYgdHlwZSAhPT0gJ2J1dCcpIHtcbiAgICAgICAgICAgICAgICBhY2MubGFzdCA9IHR5cGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRhYmxlRGVzY3JpcHRpb24gPSBzdGVwLmRhdGFUYWJsZVxuICAgICAgICAgICAgICAgID8gJ1xcbicgKyBjcmVhdGVEYXRhVGFibGUoc3RlcEFyZ3Nbc3RlcEFyZ3MubGVuZ3RoIC0gMV0ucmF3VGFibGUpXG4gICAgICAgICAgICAgICAgOiAnJztcblxuICAgICAgICAgICAgY29uc3QgZG9jU3RyaW5nRGVzY3JpcHRpb24gPSBzdGVwLmRvY1N0cmluZ1xuICAgICAgICAgICAgICAgID8gJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgc3RlcC5kb2NTdHJpbmcuY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgICAubWFwKChyb3cpID0+IHNwYWNlICsgYCR7cm93fWApXG4gICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgICAgICAgICAgICAgOiAnJztcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICAgICAgW2FjYy5sYXN0XTogW1xuICAgICAgICAgICAgICAgICAgICAuLi4oYWNjW2FjYy5sYXN0XSB8fCBbXSksXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtzdGVwLmtleXdvcmR9JHtzdGVwLnRleHR9JHt0YWJsZURlc2NyaXB0aW9ufSR7ZG9jU3RyaW5nRGVzY3JpcHRpb259YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0ZXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBkZWZpbml0aW9uLmNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwQXJnc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbGFzdDogJ2dpdmVuJyxcbiAgICAgICAgICAgIGdpdmVuOiBbXSxcbiAgICAgICAgICAgIHdoZW46IFtdLFxuICAgICAgICAgICAgdGhlbjogW11cbiAgICAgICAgfVxuICAgICk7XG59XG4iXX0=