"use strict";

var _Object$keys = require("@babel/runtime-corejs3/core-js-stable/object/keys");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols");

var _filterInstanceProperty = require("@babel/runtime-corejs3/core-js-stable/instance/filter");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor");

var _forEachInstanceProperty = require("@babel/runtime-corejs3/core-js-stable/instance/for-each");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors");

var _Object$defineProperties = require("@babel/runtime-corejs3/core-js-stable/object/define-properties");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.createDataTable = createDataTable;
exports.generateExampleTableSteps = generateExampleTableSteps;
exports.parseExampleTable = parseExampleTable;
exports.parseVariables = parseVariables;

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/toConsumableArray"));

var _asciiTable = _interopRequireDefault(require("ascii-table"));

var _space = require("../configs/space");

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context6; _forEachInstanceProperty(_context6 = ownKeys(Object(source), true)).call(_context6, function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { var _context7; _forEachInstanceProperty(_context7 = ownKeys(Object(source))).call(_context7, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

function createDataTable(rows) {
  const table = new _asciiTable.default();
  table.setHeading.apply(table, (0, _toConsumableArray2.default)(rows[0]));

  for (let i = 1; i < rows.length; i++) {
    table.addRow.apply(table, (0, _toConsumableArray2.default)(rows[i]));
  }

  const _iterable = table.toString().split('\n');

  let _result = [];

  for (let _key = 0, _length = _iterable.length, _value; _key < _length; ++_key) {
    _value = _iterable[_key];
    _result[_key] = _space.space + _value;
  }

  return _result.join('\n');
}

function generateExampleTableSteps(examples, scenario) {
  let _result2 = [];

  for (let _key2 = 0, _length2 = examples.length, _value2; _key2 < _length2; ++_key2) {
    var _context;

    _value2 = examples[_key2];
    const _iterable3 = scenario.steps;
    let _result3 = [];

    for (let _key3 = 0, _length3 = _iterable3.length, _value3; _key3 < _length3; ++_key3) {
      _value3 = _iterable3[_key3];
      _result3[_key3] = _objectSpread(_objectSpread(_objectSpread({}, _value3), _value3.docString ? {
        docString: _objectSpread(_objectSpread({}, _value3.docString), {}, {
          content: parseVariables(_value2, _value3.docString.content)
        })
      } : {}), {}, {
        text: parseVariables(_value2, _value3.text)
      });
    }

    _result2 = (0, _concat.default)(_context = []).call(_context, (0, _toConsumableArray2.default)(_result2), [_objectSpread(_objectSpread({}, scenario), {}, {
      name: parseVariables(_value2, scenario.name),
      steps: _result3
    })]);
  }

  return _result2;
}

function parseExampleTable(examples) {
  const _iterable4 = examples || [];

  let _result4 = [];

  for (let _key4 = 0, _length4 = _iterable4.length, _value4; _key4 < _length4; ++_key4) {
    var _context4;

    _value4 = _iterable4[_key4];
    const _iterable5 = _value4.tableHeader.cells;
    let _result5 = [];

    for (let _key5 = 0, _length5 = _iterable5.length, _value5; _key5 < _length5; ++_key5) {
      var _context2;

      _value5 = _iterable5[_key5];
      _result5 = (0, _concat.default)(_context2 = []).call(_context2, (0, _toConsumableArray2.default)(_result5), [_value5.value]);
    }

    const _keys = _result5;
    const _iterable6 = _value4.tableBody;
    let _result6 = [];

    for (let _key6 = 0, _length6 = _iterable6.length, _value6; _key6 < _length6; ++_key6) {
      var _context3;

      _value6 = _iterable6[_key6];
      _result6 = (0, _concat.default)(_context3 = []).call(_context3, (0, _toConsumableArray2.default)(_result6), [parseExampleTableKeyAndValues(_keys, _value6)]);
    }

    _result4 = (0, _concat.default)(_context4 = []).call(_context4, (0, _toConsumableArray2.default)(_result4), (0, _toConsumableArray2.default)(_result6));
  }

  return _result4;
}

function parseExampleTableKeyAndValues(keys, row) {
  let _result7 = [];

  for (let _key7 = 0, _length7 = keys.length, _value7; _key7 < _length7; ++_key7) {
    var _context5;

    _value7 = keys[_key7];
    _result7 = (0, _concat.default)(_context5 = []).call(_context5, (0, _toConsumableArray2.default)(_result7), [{
      key: _value7,
      value: row.cells[_key7].value
    }]);
  }

  return _result7;
}

function parseVariables(example, text) {
  let _result8 = text + '';

  for (let _key8 = 0, _length8 = example.length, _value8; _key8 < _length8; ++_key8) {
    _value8 = example[_key8];
    _result8 = _result8.replace(new RegExp(`<${_value8.key}>`), _value8.value);
  }

  return _result8;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXJzZXJzL3RhYmxlLnRzIl0sIm5hbWVzIjpbImNyZWF0ZURhdGFUYWJsZSIsInJvd3MiLCJ0YWJsZSIsIkFzY2lpVGFibGUiLCJzZXRIZWFkaW5nIiwiaSIsImxlbmd0aCIsImFkZFJvdyIsInRvU3RyaW5nIiwic3BsaXQiLCJzcGFjZSIsInJvdyIsImpvaW4iLCJnZW5lcmF0ZUV4YW1wbGVUYWJsZVN0ZXBzIiwiZXhhbXBsZXMiLCJzY2VuYXJpbyIsInN0ZXBzIiwic3RlcCIsImRvY1N0cmluZyIsImNvbnRlbnQiLCJwYXJzZVZhcmlhYmxlcyIsImV4YW1wbGUiLCJ0ZXh0IiwiYWNjIiwibmFtZSIsInBhcnNlRXhhbXBsZVRhYmxlIiwidGFibGVIZWFkZXIiLCJjZWxscyIsImNlbGwiLCJ2YWx1ZSIsImtleXMiLCJ0YWJsZUJvZHkiLCJwYXJzZUV4YW1wbGVUYWJsZUtleUFuZFZhbHVlcyIsImtleSIsInJlcGxhY2UiLCJSZWdFeHAiLCJ2YXJpYWJsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFHQTs7Ozs7O0FBRU8sU0FBU0EsZUFBVCxDQUF5QkMsSUFBekIsRUFBK0I7QUFDbEMsUUFBTUMsS0FBSyxHQUFHLElBQUlDLG1CQUFKLEVBQWQ7QUFFQUQsRUFBQUEsS0FBSyxDQUFDRSxVQUFOLE9BQUFGLEtBQUssbUNBQWVELElBQUksQ0FBQyxDQUFELENBQW5CLEVBQUw7O0FBRUEsT0FBSyxJQUFJSSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHSixJQUFJLENBQUNLLE1BQXpCLEVBQWlDRCxDQUFDLEVBQWxDLEVBQXNDO0FBQ2xDSCxJQUFBQSxLQUFLLENBQUNLLE1BQU4sT0FBQUwsS0FBSyxtQ0FBV0QsSUFBSSxDQUFDSSxDQUFELENBQWYsRUFBTDtBQUNIOztBQVBpQyxvQkFTdkJILEtBQUssQ0FBQ00sUUFBTixHQUFpQkMsS0FBakIsQ0FBdUIsSUFBdkIsQ0FUdUI7O0FBQUE7O0FBQUE7QUFBQTtBQUFBLG9CQVNnQkMsZUFBUUMsTUFUeEI7QUFBQTs7QUFTbEMsU0FBTyxRQUF3REMsSUFBeEQsQ0FBNkQsSUFBN0QsQ0FBUDtBQUNIOztBQUVNLFNBQVNDLHlCQUFULENBQW1DQyxRQUFuQyxFQUE2Q0MsUUFBN0MsRUFBdUQ7QUFBQSxpQkF5QnRELEVBekJzRDs7QUFBQSxpQ0FFdERELFFBRnNEO0FBQUE7O0FBQUEsY0FFdERBLFFBRnNEO0FBQUEsdUJBUW5DQyxRQUFRLENBQUNDLEtBUjBCO0FBQUE7O0FBQUE7QUFBQTtBQUFBLHNFQVN2Q0MsT0FUdUMsR0FVdENBLE9BQUksQ0FBQ0MsU0FBTCxHQUNFO0FBQ0lBLFFBQUFBLFNBQVMsa0NBQ0ZELE9BQUksQ0FBQ0MsU0FESDtBQUVMQyxVQUFBQSxPQUFPLEVBQUVDLGNBQWMsQ0FDbkJDLE9BRG1CLEVBRW5CSixPQUFJLENBQUNDLFNBQUwsQ0FBZUMsT0FGSTtBQUZsQjtBQURiLE9BREYsR0FVRSxFQXBCb0M7QUFxQjFDRyxRQUFBQSxJQUFJLEVBQUVGLGNBQWMsQ0FBQ0MsT0FBRCxFQUFVSixPQUFJLENBQUNLLElBQWY7QUFyQnNCO0FBQUE7O0FBQUEsbUdBSS9DQyxRQUorQyxvQ0FNM0NSLFFBTjJDO0FBTzlDUyxNQUFBQSxJQUFJLEVBQUVKLGNBQWMsQ0FBQ0MsT0FBRCxFQUFVTixRQUFRLENBQUNTLElBQW5CLENBUDBCO0FBUTlDUixNQUFBQSxLQUFLO0FBUnlDO0FBQUE7O0FBQzFEO0FBMEJIOztBQUVNLFNBQVNTLGlCQUFULENBQTJCWCxRQUEzQixFQUFxQztBQUFBLHFCQUVwQ0EsUUFBUSxJQUFJLEVBRndCOztBQUFBLGlCQXNCcEMsRUF0Qm9DOztBQUFBO0FBQUE7O0FBQUE7QUFBQSx1QkFLNUJPLE9BQU8sQ0FBQ0ssV0FBUixDQUFvQkMsS0FMUTtBQUFBLG1CQU81QixFQVA0Qjs7QUFBQTtBQUFBOztBQUFBO0FBQUEsdUdBTVRKLFFBTlMsSUFNSkssT0FBSSxDQUFDQyxLQU5EO0FBQUE7O0FBSWhDLFVBQU1DLEtBQUksV0FBVjtBQUpnQyx1QkFheEJULE9BQU8sQ0FBQ1UsU0FiZ0I7QUFBQSxtQkFrQnhCLEVBbEJ3Qjs7QUFBQTtBQUFBOztBQUFBO0FBQUEsdUdBZWpCUixRQWZpQixJQWdCcEJTLDZCQUE2QixDQUFDRixLQUFELEVBQU9uQixPQUFQLENBaEJUO0FBQUE7O0FBQUEscUdBV3pCWSxRQVh5QjtBQUFBOztBQUN4QztBQXVCSDs7QUFFRCxTQUFTUyw2QkFBVCxDQUF1Q0YsSUFBdkMsRUFBNkNuQixHQUE3QyxFQUFrRDtBQUFBLGlCQVUxQyxFQVYwQzs7QUFBQSxpQ0FFMUNtQixJQUYwQztBQUFBOztBQUFBLGNBRTFDQSxJQUYwQztBQUFBLHFHQUluQ1AsUUFKbUMsSUFLdEM7QUFDSVUsTUFBQUEsR0FBRyxFQUFIQSxPQURKO0FBRUlKLE1BQUFBLEtBQUssRUFBRWxCLEdBQUcsQ0FBQ2dCLEtBQUosQ0FBVXRCLEtBQVYsRUFBYXdCO0FBRnhCLEtBTHNDO0FBQUE7O0FBQzlDO0FBV0g7O0FBRU0sU0FBU1QsY0FBVCxDQUF3QkMsT0FBeEIsRUFBaUNDLElBQWpDLEVBQXVDO0FBQUEsaUJBTXRDQSxJQUFJLEdBQUcsRUFOK0I7O0FBQUEsaUNBRXRDRCxPQUZzQztBQUFBLGNBRXRDQSxPQUZzQztBQUFBLGVBSTNCRSxRQUFHLENBQUNXLE9BQUosQ0FBWSxJQUFJQyxNQUFKLENBQVksSUFBR0MsT0FBUSxDQUFDSCxHQUFJLEdBQTVCLENBQVosRUFBNkNHLE9BQVEsQ0FBQ1AsS0FBdEQsQ0FKMkI7QUFBQTs7QUFDMUM7QUFPSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBc2NpaVRhYmxlIGZyb20gJ2FzY2lpLXRhYmxlJztcbmltcG9ydCB7bWFwLCByZWR1Y2V9IGZyb20gJ2lubGluZS1sb29wcy5tYWNybyc7XG5cbmltcG9ydCB7c3BhY2V9IGZyb20gJy4uL2NvbmZpZ3Mvc3BhY2UnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGF0YVRhYmxlKHJvd3MpIHtcbiAgICBjb25zdCB0YWJsZSA9IG5ldyBBc2NpaVRhYmxlKCk7XG5cbiAgICB0YWJsZS5zZXRIZWFkaW5nKC4uLnJvd3NbMF0pO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRhYmxlLmFkZFJvdyguLi5yb3dzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwKHRhYmxlLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpLCAocm93KSA9PiBzcGFjZSArIHJvdykuam9pbignXFxuJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUV4YW1wbGVUYWJsZVN0ZXBzKGV4YW1wbGVzLCBzY2VuYXJpbykge1xuICAgIHJldHVybiByZWR1Y2UoXG4gICAgICAgIGV4YW1wbGVzLFxuICAgICAgICAoYWNjLCBleGFtcGxlKSA9PiBbXG4gICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLi4uc2NlbmFyaW8sXG4gICAgICAgICAgICAgICAgbmFtZTogcGFyc2VWYXJpYWJsZXMoZXhhbXBsZSwgc2NlbmFyaW8ubmFtZSksXG4gICAgICAgICAgICAgICAgc3RlcHM6IG1hcChzY2VuYXJpby5zdGVwcywgKHN0ZXApID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIC4uLnN0ZXAsXG4gICAgICAgICAgICAgICAgICAgIC4uLihzdGVwLmRvY1N0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2NTdHJpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGVwLmRvY1N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBwYXJzZVZhcmlhYmxlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhbXBsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcC5kb2NTdHJpbmcuY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHBhcnNlVmFyaWFibGVzKGV4YW1wbGUsIHN0ZXAudGV4dClcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgW11cbiAgICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFeGFtcGxlVGFibGUoZXhhbXBsZXMpIHtcbiAgICByZXR1cm4gcmVkdWNlKFxuICAgICAgICBleGFtcGxlcyB8fCBbXSxcbiAgICAgICAgKGFjYywgZXhhbXBsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IHJlZHVjZShcbiAgICAgICAgICAgICAgICBleGFtcGxlLnRhYmxlSGVhZGVyLmNlbGxzLFxuICAgICAgICAgICAgICAgIChhY2MsIGNlbGwpID0+IFsuLi5hY2MsIGNlbGwudmFsdWVdLFxuICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgICAgICAuLi5yZWR1Y2UoXG4gICAgICAgICAgICAgICAgICAgIGV4YW1wbGUudGFibGVCb2R5LFxuICAgICAgICAgICAgICAgICAgICAoYWNjLCByb3cpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRXhhbXBsZVRhYmxlS2V5QW5kVmFsdWVzKGtleXMsIHJvdylcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgW11cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuICAgICAgICBbXVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXhhbXBsZVRhYmxlS2V5QW5kVmFsdWVzKGtleXMsIHJvdykge1xuICAgIHJldHVybiByZWR1Y2UoXG4gICAgICAgIGtleXMsXG4gICAgICAgIChhY2MsIGtleSwgaSkgPT4gW1xuICAgICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcm93LmNlbGxzW2ldLnZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFtdXG4gICAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVmFyaWFibGVzKGV4YW1wbGUsIHRleHQpIHtcbiAgICByZXR1cm4gcmVkdWNlKFxuICAgICAgICBleGFtcGxlLFxuICAgICAgICAoYWNjLCB2YXJpYWJsZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFjYy5yZXBsYWNlKG5ldyBSZWdFeHAoYDwke3ZhcmlhYmxlLmtleX0+YCksIHZhcmlhYmxlLnZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dCArICcnXG4gICAgKTtcbn1cbiJdfQ==