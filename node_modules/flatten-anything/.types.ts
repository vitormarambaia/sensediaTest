type ToNestedTuple<T> = { [K in keyof T]: [K, T[K] extends object | unknown[] ? ToNestedTuple<T[K]> : T[K]] }[keyof T]

type UnionToIntersection<U> = (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never

type TupleExcludingLast<
  Tuple extends ReadonlyArray<unknown>,
> = (
  Tuple extends [...infer Head, infer Tail]
  ? Head
  : never
);

type TupleLast<Tuple extends ReadonlyArray<unknown>> = (
  Tuple extends [...infer Head, infer Tail]
  ? Tail
  : never
);

type Join<
  Tuple extends ReadonlyArray<string>,
  Separator extends string = "",
  ResultSoFar extends string | undefined = undefined
> = (
  Tuple extends []
  ? ResultSoFar
  : ResultSoFar extends undefined ? Join<TupleExcludingLast<Tuple>, Separator, TupleLast<Tuple>> : Join<TupleExcludingLast<Tuple>, Separator, `${TupleLast<Tuple>}${Separator}${ResultSoFar}`>
)

type FlattenTuples<T, Prefix extends string|undefined = undefined> = T extends [infer A, infer B] ? 
  B extends unknown[]
  ? Prefix extends undefined
  ? FlattenTuples<B, Join<[A & string], '.'>>
  : FlattenTuples<B, Join<[Prefix & string, A & string], '.'>>
  : Prefix extends undefined
  ? { [K in A & string]: B }
  : { [K in Join<[Prefix &string, A & string],'.'>] : B}
  : never

export type Flatten<T> = UnionToIntersection<FlattenTuples<ToNestedTuple<T>>>
