"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initializeFormatters = void 0;
const util_1 = require("util");
const value_checker_1 = require("../value_checker");
const builder_1 = __importDefault(require("../formatter/builder"));
const fs_1 = __importDefault(require("mz/fs"));
const path_1 = __importDefault(require("path"));
const publish_1 = require("../formatter/publish");
const http_stream_1 = __importDefault(require("../formatter/http_stream"));
const stream_1 = require("stream");
async function initializeFormatters({ cwd, stdout, eventBroadcaster, eventDataCollector, configuration = {}, supportCodeLibrary, }) {
    var _a;
    async function initializeFormatter(stream, target, type) {
        var _a, _b;
        stream.on('error', (error) => {
            console.error(error.message);
            process.exit(1);
        });
        const typeOptions = {
            cwd,
            eventBroadcaster,
            eventDataCollector,
            log: stream.write.bind(stream),
            parsedArgvOptions: (_a = configuration.options) !== null && _a !== void 0 ? _a : {},
            stream,
            cleanup: stream === stdout
                ? async () => await Promise.resolve()
                : (0, util_1.promisify)(stream.end.bind(stream)),
            supportCodeLibrary,
        };
        if ((0, value_checker_1.doesNotHaveValue)((_b = configuration.options) === null || _b === void 0 ? void 0 : _b.colorsEnabled)) {
            typeOptions.parsedArgvOptions.colorsEnabled = stream.isTTY;
        }
        if (type === 'progress-bar' && !stream.isTTY) {
            console.warn(`Cannot use 'progress-bar' formatter for output to '${target}' as not a TTY. Switching to 'progress' formatter.`);
            type = 'progress';
        }
        return await builder_1.default.build(type, typeOptions);
    }
    const formatters = [];
    formatters.push(await initializeFormatter(stdout, 'stdout', (_a = configuration.stdout) !== null && _a !== void 0 ? _a : 'progress'));
    if (configuration.files) {
        for (const [target, type] of Object.entries(configuration.files)) {
            const stream = fs_1.default.createWriteStream(null, {
                fd: await fs_1.default.open(path_1.default.resolve(cwd, target), 'w'),
            });
            formatters.push(await initializeFormatter(stream, target, type));
        }
    }
    if (configuration.publish) {
        const { url = publish_1.DEFAULT_CUCUMBER_PUBLISH_URL, token } = configuration.publish;
        const headers = {};
        if (token !== undefined) {
            headers.Authorization = `Bearer ${token}`;
        }
        const stream = new http_stream_1.default(url, 'GET', headers);
        const readerStream = new stream_1.Writable({
            objectMode: true,
            write: function (responseBody, encoding, writeCallback) {
                console.error(responseBody);
                writeCallback();
            },
        });
        stream.pipe(readerStream);
        formatters.push(await initializeFormatter(stream, url, 'message'));
    }
    return async function () {
        await Promise.all(formatters.map(async (f) => await f.finished()));
    };
}
exports.initializeFormatters = initializeFormatters;
//# sourceMappingURL=formatters.js.map